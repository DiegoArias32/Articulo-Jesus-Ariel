\section{Introducción}

Cuando comenzamos este proyecto, lo primero que nos llamó la atención al visitar las oficinas de Electrohuila fue la sala de espera. Filas de personas esperando su turno, algunos llevaban más de dos horas allí. No era algo inusual: en promedio, los ciudadanos pasaban entre 90 y 120 minutos solo para ser atendidos en temas relacionados con Peticiones, Quejas y Reclamos (PQR) sobre sus servicios de energía eléctrica. Esta situación no solo generaba frustración entre los usuarios, sino que también representaba una carga operativa considerable para Electrohuila, empresa que presta servicios públicos de energía eléctrica a más de 400,000 usuarios en el departamento del Huila, Colombia.

La problemática era evidente, pero la solución no tanto. Electrohuila necesitaba modernizar urgentemente su sistema de atención ciudadana. Sin embargo, esto no se trataba simplemente de implementar cualquier solución tecnológica. La empresa requería un sistema que pudiera integrarse con sus procesos existentes, que fuera lo suficientemente robusto para manejar los picos de demanda (especialmente después de apagones o problemas en el servicio), y que al mismo tiempo fuera accesible para una población diversa que incluía desde jóvenes familiarizados con la tecnología hasta adultos mayores que apenas estaban empezando a usar smartphones.

Este proyecto nació precisamente de esa necesidad real y tangible. Se trataba de desarrollar un Sistema de Agendamiento de Citas PQR que pudiera transformar completamente la manera en que los ciudadanos interactúan con Electrohuila. El objetivo principal era claro: permitir que los usuarios agendaran sus citas de manera autónoma, desde la comodidad de sus hogares, eliminando las largas esperas y optimizando los recursos de la empresa. Pero como suele ocurrir en proyectos reales, había muchas más consideraciones bajo la superficie.

El desarrollo del sistema representó un desafío técnico y organizacional considerable. No estábamos construyendo una simple aplicación de agendamiento; estábamos creando una solución empresarial completa que debía funcionar de manera confiable en un entorno crítico. Después de todo, estamos hablando de un servicio público esencial. Si el sistema fallaba o presentaba problemas, podría afectar directamente la capacidad de miles de personas para resolver sus problemas con el servicio eléctrico, lo cual podía tener consecuencias serias en sus vidas cotidianas.

La arquitectura que diseñamos constaba de tres componentes fundamentales, cada uno con su propio conjunto de desafíos. Primero, desarrollamos un portal administrativo web pensado específicamente para el personal interno de Electrohuila. Este portal no era simplemente una interfaz bonita; tenía que ser una herramienta poderosa que permitiera a los administradores gestionar todo el ecosistema del sistema: desde la creación y asignación de empleados a diferentes sucursales hasta la configuración de horarios de atención, pasando por el manejo de roles y permisos de acceso con un nivel de granularidad bastante detallado. Durante las reuniones con los supervisores de Electrohuila, nos dimos cuenta de que cada sucursal tenía sus propias particularidades. Por ejemplo, la oficina principal en Neiva manejaba todos los tipos de PQR, mientras que algunas oficinas más pequeñas en municipios solo podían atender ciertos tipos de solicitudes. El sistema tenía que reflejar esta complejidad operativa.

El segundo componente era la aplicación móvil para ciudadanos. Este fue, quizás, el componente más delicado desde el punto de vista de experiencia de usuario. Teníamos que lograr un equilibrio difícil: crear una interfaz lo suficientemente simple para que cualquier persona pudiera usarla sin problemas, pero al mismo tiempo lo suficientemente completa para cubrir todas las funcionalidades necesarias. Después de varias iteraciones y pruebas con usuarios reales (organizamos sesiones de prueba con empleados de Electrohuila y algunos de sus familiares), decidimos seguir el patrón Model-View-ViewModel (MVVM) para la aplicación móvil. Esta decisión arquitectónica nos permitió mantener una separación clara entre la interfaz de usuario y la lógica de negocio, lo que facilitó enormemente las pruebas y el mantenimiento del código.

La aplicación móvil debía funcionar tanto en Android como en iOS. Aquí tomamos una decisión que algunos podrían considerar arriesgada: usar .NET MAUI, un framework relativamente nuevo en ese momento. ¿Por qué? Bueno, consideramos varias alternativas como React Native o Flutter, pero finalmente nos decidimos por MAUI principalmente porque nos permitiría mantener un stack tecnológico más unificado con el backend, que ya estábamos desarrollando en .NET. Además, el equipo de desarrollo ya tenía experiencia con C\# y el ecosistema .NET, lo que reducía la curva de aprendizaje y potencialmente aceleraba el desarrollo.

El tercer y más complejo componente era el backend: una API RESTful que actuaría como el cerebro del sistema entero. Este backend tenía que hacer mucho más que simplemente almacenar y recuperar datos. Necesitaba validar la disponibilidad de citas en tiempo real (considerando horarios de empleados, días festivos, citas ya agendadas, capacidad de cada sucursal), gestionar las notificaciones push a través de SignalR, mantener la integridad de los datos ante operaciones concurrentes, y exponer endpoints seguros y bien documentados tanto para el portal web como para la aplicación móvil.

Para el backend, nos decidimos por implementar Clean Architecture, una decisión que inicialmente generó cierto debate en el equipo. Algunos argumentaban que era "demasiado" para un proyecto de esta escala, que estábamos sobre-diseñando la solución. Sin embargo, defendimos esta decisión basándonos en varios factores. Primero, queríamos que el sistema fuera realmente mantenible a largo plazo. Electrohuila no iba a contratar un equipo de desarrollo permanente después del proyecto; necesitaban que cualquier programador con conocimientos de .NET pudiera entender y modificar el código en el futuro. Clean Architecture, con su separación clara en capas (Domain, Application, Infrastructure, Presentation), hace que el código sea mucho más fácil de entender y modificar sin romper funcionalidades existentes.

Segundo, las pruebas unitarias eran fundamentales. En un sistema que maneja servicios públicos críticos, no podíamos darnos el lujo de tener bugs que pasaran desapercibidos hasta producción. La arquitectura limpia nos permitió escribir pruebas unitarias de manera mucho más sencilla, especialmente para la lógica de negocio que residía en la capa de Application, completamente independiente de frameworks o bases de datos específicas. Durante el desarrollo, llegamos a tener más de 150 pruebas unitarias cubriendo los casos de uso más críticos del sistema.

En cuanto a la selección del stack tecnológico, hubo varias decisiones importantes que vale la pena mencionar. Para el backend, elegimos .NET 9, que en ese momento era la versión LTS (Long Term Support) más reciente. Esto nos daba garantías de soporte y actualizaciones por varios años, algo importante para un proyecto empresarial. Entity Framework Core actuó como nuestro ORM (Object-Relational Mapper), facilitando enormemente las interacciones con la base de datos y permitiéndonos trabajar con objetos C\# en lugar de SQL directo en la mayoría de los casos.

La decisión de usar Oracle Database como sistema gestor de base de datos no fue nuestra, sino un requerimiento de Electrohuila. La empresa ya tenía toda su infraestructura de datos en Oracle, y migrar a otro sistema (como PostgreSQL o SQL Server) simplemente no era una opción viable. Esto presentó sus propios desafíos. Oracle tiene sus particularidades, especialmente en cómo maneja las secuencias para generar IDs, las transacciones, y ciertos tipos de datos. Tuvimos que configurar Entity Framework Core cuidadosamente para que funcionara correctamente con Oracle, algo que nos tomó varios días de investigación y pruebas.

Para el portal administrativo web, optamos por Next.js 15 con TypeScript. Next.js nos proporcionaba capacidades de renderizado del lado del servidor (SSR) que mejoraban significativamente el rendimiento inicial y el SEO, aunque para una aplicación administrativa interna el SEO no era tan crítico. TypeScript fue no negociable desde el principio; con un equipo de varios desarrolladores trabajando en el mismo proyecto, el tipado estático nos salvó de innumerables bugs potenciales. Cuántas veces el compilador de TypeScript nos alertó sobre un cambio en una interfaz que habíamos olvidado actualizar en algún componente.

Para el manejo de estado en la aplicación web, elegimos Zustand en lugar de opciones más populares como Redux o MobX. ¿Por qué? Zustand es significativamente más simple de configurar y usar, con mucho menos boilerplate code. Para un proyecto de este tamaño, no necesitábamos la complejidad adicional de Redux. Zustand nos dio exactamente lo que necesitábamos: un store centralizado, fácil de actualizar, y con muy buena integración con React hooks.

SignalR fue la pieza clave para las notificaciones en tiempo real. Queríamos que cuando un administrador confirmara una cita, el usuario viera inmediatamente esa actualización en su aplicación móvil sin necesidad de refrescar manualmente. También lo usamos para notificar al personal administrativo cuando se agendaban nuevas citas. Implementar SignalR presentó sus propios desafíos técnicos, especialmente en el manejo de la reconexión automática cuando los usuarios perdían temporalmente su conexión a internet, algo bastante común en algunas zonas del Huila.

El alcance funcional del sistema fue creciendo orgánicamente a medida que avanzábamos y descubríamos nuevos requerimientos. Inicialmente, el sistema de gestión de citas parecía relativamente directo: crear una cita, confirmarla, completarla o cancelarla. Sin embargo, pronto nos dimos cuenta de que necesitábamos un sistema mucho más sofisticado de validaciones. ¿Qué pasa si dos usuarios intentan agendar la misma cita exactamente al mismo tiempo? ¿Cómo manejamos los bloqueos de horarios cuando un empleado se enferma? ¿Qué sucede con las citas ya agendadas cuando se declara un día festivo de último momento?

Estos escenarios del mundo real nos llevaron a implementar un sistema robusto de manejo de estados para las citas. No solo teníamos los estados básicos (agendada, confirmada, completada, cancelada), sino que también agregamos estados de transición y validaciones complejas. Por ejemplo, implementamos locks optimistas en la base de datos para prevenir condiciones de carrera cuando múltiples usuarios intentaban agendar la misma hora disponible.

La gestión de empleados resultó ser más compleja de lo anticipado. No se trataba solo de crear registros de empleados en la base de datos. Necesitábamos asociar cada empleado con sucursales específicas (algunos empleados rotaban entre sucursales), definir sus horarios de atención (que podían variar día a día), especificar qué tipos de PQR podían manejar, y todo esto considerando permisos, vacaciones y ausencias. Desarrollamos un módulo completo solo para la gestión de horarios que permitía a los administradores definir plantillas de horarios semanales y luego hacer excepciones según fuera necesario.

El sistema de roles y permisos granulares fue otro componente crítico. En Electrohuila, no todos los empleados administrativos deberían tener acceso a todas las funcionalidades del sistema. Un supervisor regional necesitaba ver y gestionar todas las sucursales de su región, pero no las de otras regiones. Un administrador de sucursal solo debería poder gestionar los empleados de su propia sucursal. Implementamos un sistema basado en claims con ASP.NET Core Identity que nos permitió definir permisos muy específicos para cada acción (crear empleados, modificar horarios, ver reportes, etc.) y luego asignar estos permisos a roles, que finalmente se asignaban a usuarios.

Los días festivos parecían un detalle menor al principio, pero resultaron ser sorprendentemente complicados. Colombia tiene días festivos nacionales, pero también tiene leyes específicas sobre cómo se trasladan algunos festivos al lunes siguiente si caen en domingo (la famosa "Ley Emiliani"). Además, algunos festivos son específicos de ciertas regiones o municipios. Necesitábamos que el sistema manejara todo esto automáticamente y que bloqueara automáticamente la disponibilidad de citas en esos días, pero también que permitiera excepciones si Electrohuila decidía abrir excepcionalmente alguna sucursal en un día festivo.

Todo este proyecto se desarrolló en el contexto del programa de formación del SENA (Servicio Nacional de Aprendizaje). Para nosotros como equipo de desarrollo, esto significó no solo construir un sistema funcional, sino también documentar exhaustivamente cada decisión, cada patrón de diseño aplicado, cada desafío superado. Fue un ejercicio valioso de reflexión técnica que, honestamente, mejoró la calidad del producto final. Cuando tienes que explicar por qué elegiste una arquitectura específica o una tecnología particular, te obligas a ti mismo a pensar más profundamente sobre esas decisiones.

Una de las lecciones más valiosas que aprendimos fue la importancia de la comunicación constante con el cliente. Electrohuila tenía una idea general de lo que querían, pero muchos detalles solo surgieron cuando empezamos a mostrar prototipos funcionales. Las reuniones semanales de revisión fueron cruciales. Recuerdo específicamente una reunión donde mostramos la interfaz de agendamiento de citas en la app móvil, y uno de los supervisores comentó: "Esto está muy bien, pero ¿qué pasa si el usuario necesita cancelar una cita?". Nos dimos cuenta de que habíamos diseñado todo el flujo de creación de citas, pero no habíamos considerado adecuadamente el flujo de cancelación y reprogramación. Ese tipo de feedback temprano nos ahorró muchísimo trabajo de rehacer funcionalidades más adelante.

El testing fue otra área donde aprendimos mucho. Inicialmente pensábamos que con pruebas unitarias sería suficiente, pero pronto nos dimos cuenta de que necesitábamos pruebas de integración para validar que todos los componentes funcionaban correctamente juntos. Configuramos un ambiente de staging que replicaba el ambiente de producción lo más fielmente posible, y allí ejecutábamos pruebas de integración automatizadas además de sesiones de pruebas manuales exploratorias. Estas pruebas descubrieron varios problemas que nunca hubiéramos encontrado solo con pruebas unitarias, especialmente relacionados con la sincronización de datos entre el backend y los clientes.

El rendimiento fue una preocupación constante. No queríamos crear un sistema que funcionara bien con 10 usuarios pero se cayera con 100 usuarios simultáneos. Realizamos pruebas de carga usando herramientas como Apache JMeter para simular múltiples usuarios concurrentes agendando citas, consultando disponibilidad, etc. Estas pruebas nos ayudaron a identificar cuellos de botella. Por ejemplo, descubrimos que nuestra consulta inicial para calcular disponibilidad de horarios era extremadamente ineficiente; estaba generando múltiples consultas a la base de datos en un loop. La optimizamos usando técnicas de eager loading con Entity Framework Core y agregando índices estratégicos en la base de datos, reduciendo el tiempo de respuesta de casi 3 segundos a menos de 200 milisegundos.

La seguridad fue otro pilar fundamental que consideramos desde el primer día. Implementamos autenticación basada en JWT (JSON Web Tokens) para la API, con tokens de corta duración (15 minutos) y refresh tokens para mantener sesiones activas sin comprometer la seguridad. Todos los endpoints requieren autenticación excepto el de login, y adicionalmente muchos requieren permisos específicos verificados a nivel de endpoint. También implementamos rate limiting para prevenir ataques de denegación de servicio, y validación exhaustiva de todos los inputs del usuario para prevenir inyecciones SQL y otros ataques comunes.

Mirando hacia atrás, este proyecto representa mucho más que simplemente la entrega de un software funcional. Es un caso de estudio completo sobre cómo aplicar principios modernos de ingeniería de software en un contexto real con restricciones y requerimientos empresariales genuinos. Documentar todo este proceso, desde las decisiones arquitectónicas iniciales hasta los desafíos técnicos superados y las lecciones aprendidas, contribuye al cuerpo de conocimiento en el campo de sistemas de información empresariales.

Creemos que esta experiencia puede ser valiosa para otros desarrolladores, estudiantes de ingeniería de software, y equipos que enfrenten proyectos similares. No es lo mismo leer sobre Clean Architecture o MVVM en un libro que aplicarlos en un proyecto real donde hay deadlines, clientes con expectativas específicas, restricciones técnicas impuestas por infraestructura existente, y todas las complicaciones maravillosas que trae el desarrollo de software en el mundo real. Los tutoriales online raramente mencionan qué hacer cuando tu ORM no se lleva bien con Oracle, o cómo manejar la frustración cuando descubres tres días antes de la entrega que hay un requerimiento crítico que nadie había mencionado antes.

El resto de este artículo está organizado para guiar al lector a través de todo el proceso de desarrollo del sistema. En la Sección II, revisamos trabajos relacionados y sistemas similares que existen en el mercado, analizando tanto soluciones comerciales como desarrollos académicos previos sobre sistemas de agendamiento y arquitecturas de software modernas. Esto nos ayuda a contextualizar nuestro trabajo dentro del estado del arte actual.

La Sección III se adentra en la metodología de desarrollo que seguimos, explicando detalladamente las tres fases principales: análisis y diseño, donde definimos requerimientos y creamos los diseños arquitectónicos; implementación, donde construimos el sistema componente por componente; y pruebas, donde validamos que todo funcionara correctamente tanto a nivel individual como integrado.

En la Sección IV presentamos la implementación técnica del sistema de manera profunda. Aquí es donde explicamos las decisiones arquitectónicas específicas, justificamos la selección de cada tecnología del stack, y describimos cómo implementamos los componentes críticos del sistema. Incluimos diagramas de arquitectura, fragmentos de código representativos, y explicaciones de los patrones de diseño aplicados.

La Sección V presenta los resultados obtenidos. No solo enumeramos las funcionalidades implementadas, sino que también proporcionamos métricas concretas de rendimiento, resultados de pruebas de carga, y feedback recibido de los usuarios durante las pruebas de aceptación.

En la Sección VI discutimos en profundidad las decisiones de diseño más importantes, los desafíos técnicos y organizacionales que enfrentamos (algunos de los cuales ya hemos mencionado brevemente aquí), y las lecciones aprendidas que podrían ayudar a otros equipos a evitar los mismos errores que nosotros cometimos.

Finalmente, la Sección VII concluye el artículo resumiendo las contribuciones principales del proyecto y esbozando posibles líneas de trabajo futuro que podrían mejorar o extender el sistema, como la integración con sistemas de pago electrónico o la implementación de un chatbot con inteligencia artificial para consultas básicas.
