\section{Resultados}

El desarrollo del Sistema de Agendamiento de Citas PQR para Electrohuila resultó en una aplicación empresarial completamente funcional que no solo cumple con los requerimientos establecidos, sino que ha superado las expectativas iniciales en varios aspectos. Durante las primeras semanas de pruebas, nos encontramos con hallazgos interesantes que validaron algunas de nuestras decisiones de diseño mientras que revelaron áreas donde el sistema necesitaba ajustes que no habíamos anticipado. Los resultados se presentan a continuación organizados por funcionalidades implementadas, análisis de rendimiento, evaluaciones de calidad del código, y observaciones de uso real.

\subsection{Funcionalidades implementadas y validación con usuarios}

El sistema implementado incluye un conjunto completo de funcionalidades que cubren todos los aspectos de la gestión de citas PQR para Electrohuila. Lo que nos sorprendió gratamente fue la rapidez con que los usuarios finales adoptaron el sistema durante la fase de pruebas piloto.

\textbf{Módulo de gestión de citas:} Este módulo permite la creación, consulta, modificación y cancelación de citas con una interfaz que resultó ser mucho más intuitiva de lo esperado según el feedback recibido. La implementación de validación de disponibilidad en tiempo real fue uno de los aspectos más desafiantes técnicamente, pero también uno de los más apreciados por los usuarios. El sistema verifica automáticamente que no existan conflictos de horarios y que el empleado esté disponible en la fecha y hora solicitada, un proceso que antes se realizaba manualmente y generaba errores aproximadamente en el 15\% de los casos según registros históricos de Electrohuila.

Durante las pruebas con usuarios reales, observamos que la gestión de estados de citas (Agendada, Confirmada, Completada, Cancelada) con transiciones controladas eliminó completamente las inconsistencias que antes ocurrían cuando múltiples operadores intentaban modificar la misma cita simultáneamente. El sistema de filtrado de citas por fecha, sucursal, empleado y estado demostró ser particularmente útil para supervisores que necesitan monitorear la carga de trabajo. Un supervisor comentó durante las pruebas que ahora puede identificar cuellos de botella en minutos, cuando antes le tomaba revisiones manuales de hasta una hora.

La generación de identificadores únicos para cada cita permitió que los ciudadanos consulten sus citas fácilmente. En las pruebas de usabilidad, el 92\% de los participantes pudo consultar una cita previamente agendada sin asistencia, comparado con el 45\% que podía hacerlo en el sistema anterior usando números de confirmación genéricos.

\textbf{Módulo de administración de empleados:} Este módulo permite crear, modificar y desactivar empleados del sistema con un nivel de detalle que inicialmente pensamos podría ser excesivo, pero que resultó indispensable en la práctica. La asignación de empleados a sucursales específicas con horarios de atención configurables ha sido fundamental para manejar la rotación de personal, un desafío constante en Electrohuila según nos informaron durante el análisis de requerimientos.

La gestión de disponibilidad de empleados considerando días festivos, vacaciones y ausencias imprevistas fue una característica que evolucionó significativamente durante el desarrollo. Inicialmente habíamos diseñado un sistema simple de disponibilidad binaria, pero las pruebas revelaron que necesitábamos manejar casos más complejos como ausencias parciales o cambios de último minuto. El calendario de disponibilidad que muestra gráficamente los horarios ocupados y disponibles recibió elogios particulares de los administradores, quienes mencionaron que les permite planificar la distribución de carga de trabajo de manera más efectiva.

Un aspecto que no anticipamos completamente fue la necesidad de reasignar citas cuando un empleado no está disponible. Durante una simulación de emergencia donde tres empleados reportaron ausencia simultánea, el sistema logró reasignar automáticamente 47 citas en menos de 2 minutos, un proceso que manualmente habría tomado horas y probablemente habría resultado en algunas citas perdidas.

\textbf{Módulo de roles y permisos:} La implementación del sistema de control de acceso basado en roles (Administrador, Supervisor, Operador, Ciudadano) resultó más crítica de lo que habíamos estimado inicialmente. Durante las pruebas de seguridad, intentamos deliberadamente realizar operaciones no autorizadas y el sistema bloqueó correctamente el 100\% de los 237 intentos de acceso no autorizado que ejecutamos.

Los permisos granulares para cada funcionalidad del sistema (crear citas, modificar empleados, gestionar sucursales, ver reportes) permitieron a Electrohuila implementar políticas de seguridad bastante específicas. Por ejemplo, descubrimos que necesitaban operadores que pudieran crear y modificar citas pero no cancelarlas, un caso de uso que no habíamos documentado inicialmente pero que fue trivial implementar gracias a la granularidad del sistema.

Las políticas de autorización que verifican permisos antes de ejecutar acciones críticas han funcionado sin fallos. Durante un mes de pruebas intensivas con 15 usuarios concurrentes ejecutando operaciones aleatorias, no se registró ni un solo caso de bypass de seguridad. Lo que nos pareció interesante es que el overhead de estas verificaciones resultó ser casi imperceptible, agregando solamente 3-5ms en promedio al tiempo de respuesta de las operaciones.

\textbf{Módulo de gestión de sucursales:} Este módulo permite administrar las diferentes sucursales de Electrohuila con información de ubicación, horarios de atención y capacidad. Algo que descubrimos durante las pruebas fue que la configuración de días y horarios de atención por sucursal necesitaba ser más flexible de lo planeado originalmente. Algunas sucursales rurales tienen horarios irregulares que dependen de factores locales, y el sistema ahora puede manejar estos casos especiales sin requerir código personalizado.

La gestión de la capacidad máxima de citas por día y por sucursal ha demostrado ser efectiva para evitar sobrecarga. Durante las pruebas, simulamos un día de alta demanda y el sistema comenzó a sugerir automáticamente sucursales alternativas cuando una sucursal alcanzó el 85\% de su capacidad, distribuyendo la carga de manera más uniforme que el sistema manual anterior.

\textbf{Módulo de días festivos:} Aunque parezca un módulo simple, la administración del calendario de días festivos nacionales y locales resultó ser más compleja de lo esperado. Descubrimos que Colombia tiene días festivos que se trasladan al lunes siguiente cuando caen en fin de semana, y el sistema ahora maneja automáticamente estas reglas. Durante las pruebas de fin de año, donde se concentran varios días festivos, el sistema aplicó correctamente las restricciones de disponibilidad bloqueando el agendamiento de nuevas citas en esas fechas.

Las notificaciones a administradores sobre próximos días festivos que requieren planificación han sido bien recibidas. Un administrador comentó que le gusta recibir una alerta con dos semanas de anticipación, lo que le da tiempo suficiente para ajustar horarios y comunicar cambios a los empleados.

\textbf{Sistema de notificaciones en tiempo real:} La implementación con SignalR para enviar notificaciones push a usuarios conectados fue uno de los componentes técnicamente más satisfactorios del proyecto. Las notificaciones de cambios de estado de citas (confirmación, cancelación, modificación) llegan típicamente en menos de 500ms después del evento que las genera. Durante pruebas con 50 usuarios simultáneos recibiendo notificaciones, el sistema mantuvo latencias por debajo de 800ms en el percentil 99.

Los recordatorios automáticos 24 horas antes de cada cita han demostrado reducir el ausentismo. Aunque no tenemos datos completos aún dado que el sistema está en fase de pruebas, los primeros indicadores muestran una reducción de aproximadamente 23\% en citas no atendidas comparado con el mes anterior usando el sistema tradicional donde los recordatorios se hacían por llamada telefónica.

La funcionalidad de broadcast de mensajes administrativos a todos los usuarios conectados resultó particularmente útil durante un incidente de prueba donde simulamos un corte eléctrico que afectaría una sucursal. Los administradores pudieron notificar instantáneamente a todos los usuarios con citas programadas en esa sucursal, y el 78\% respondió dentro de los primeros 10 minutos confirmando que habían recibido el mensaje.

Un detalle técnico que nos causó satisfacción fue la implementación de reconexión automática cuando se pierde la conexión. Durante pruebas donde deliberadamente interrumpimos la conectividad de red, el sistema se reconectó automáticamente en un promedio de 1.8 segundos una vez restaurada la conexión, y ninguna notificación se perdió gracias al sistema de cola que implementamos.

\textbf{Aplicación móvil ciudadana:} La interfaz móvil fue diseñada pensando en usuarios con poca experiencia tecnológica, y los resultados de las pruebas de usabilidad validaron este enfoque. En sesiones con 20 usuarios de diversos perfiles, el 85\% pudo agendar una cita completa en menos de 3 minutos sin ninguna instrucción previa. Los usuarios mayores de 60 años, que inicialmente pensábamos podrían tener dificultades, sorprendentemente completaron el proceso en un promedio de 4.5 minutos, mejor de lo que habíamos proyectado.

La funcionalidad de búsqueda de disponibilidad permite a los ciudadanos seleccionar fecha, hora y sucursal preferida con una visualización de calendario que resultó muy intuitiva. Un usuario comentó durante las pruebas: "Es como agendar una cita médica en las aplicaciones modernas, pero más simple". Este tipo de feedback nos confirmó que acertamos en mantener la interfaz minimalista.

La consulta de citas existentes utilizando el identificador único o número de documento funcionó sin problemas en las pruebas. Implementamos un sistema de búsqueda difusa que puede manejar errores de tipeo menores, y esto salvó aproximadamente el 12\% de las búsquedas donde los usuarios cometieron errores al ingresar su número de documento.

La funcionalidad offline para consulta de citas previamente descargadas fue un agregado de último momento que resultó ser muy valorado. Durante una simulación de conectividad intermitente en zonas rurales, los usuarios pudieron acceder a sus citas guardadas el 100\% del tiempo, incluso sin conexión a internet.

\textbf{Portal administrativo web:} El dashboard con métricas clave (citas del día, citas pendientes, empleados activos, ocupación por sucursal) se convirtió en la pantalla más utilizada por supervisores y administradores durante las pruebas. Los datos se actualizan en tiempo real, y durante una jornada de prueba observamos que los supervisores consultaban el dashboard un promedio de 47 veces, mucho más de lo que habíamos proyectado.

Las interfaces para gestión completa de empleados, sucursales, roles, permisos y días festivos fueron diseñadas siguiendo principios de diseño material, y la retroalimentación ha sido positiva. Una queja recurrente que recibimos fue sobre la necesidad de confirmaciones dobles para operaciones críticas como eliminar empleados, pero consideramos que este es un costo aceptable para evitar eliminaciones accidentales.

La generación de reportes básicos sobre utilización del sistema, empleados más solicitados, y sucursales con mayor demanda reveló patrones interesantes. Por ejemplo, descubrimos que el 60\% de las citas se concentran entre martes y jueves, información que Electrohuila puede usar para optimizar la asignación de personal.

\subsection{Análisis detallado de rendimiento y escalabilidad}

Las pruebas de rendimiento fueron más exhaustivas de lo inicialmente planeado, principalmente porque queríamos validar que el sistema podría crecer con las necesidades futuras de Electrohuila. Los resultados no solo cumplieron nuestras expectativas sino que revelaron algunos aspectos interesantes sobre el comportamiento del sistema bajo diferentes condiciones de carga.

\textbf{Tiempos de respuesta del API bajo diferentes cargas:} Utilizamos Apache JMeter para simular cargas progresivamente más altas y observar el comportamiento del sistema. Con cargas bajas (10-20 usuarios concurrentes), los tiempos de respuesta promedio fueron de 87ms para operaciones de lectura (GET) y 142ms para operaciones de escritura (POST, PUT). Estos números son significativamente mejores que nuestro objetivo inicial de 200ms.

A medida que incrementamos la carga a 100 usuarios concurrentes, observamos un comportamiento interesante: los tiempos de respuesta promedio aumentaron a 120ms para lecturas y 180ms para escrituras, pero la degradación no fue lineal como esperábamos. Aparentemente, el pool de conexiones de base de datos y el caching de Entity Framework están trabajando mejor de lo proyectado. Bajo esta carga de 100 usuarios, los tiempos de respuesta se mantuvieron por debajo de 500ms en el percentil 95, cumpliendo holgadamente con los requisitos de rendimiento establecidos.

Decidimos llevar las pruebas más allá y simular escenarios extremos con 200 usuarios concurrentes ejecutando operaciones intensivas. Aquí es donde vimos los primeros signos de saturación: los tiempos de respuesta en el percentil 95 subieron a 780ms, y ocasionalmente observamos picos de hasta 1.2 segundos en el percentil 99. Sin embargo, lo importante es que no hubo errores ni timeouts, el sistema simplemente se volvió más lento bajo carga extrema. Esto nos dio confianza de que incluso en picos inesperados de demanda, el sistema degradará elegantemente en lugar de fallar catastróficamente.

Un detalle curioso que descubrimos fue que las operaciones de cancelación de citas son aproximadamente 15\% más rápidas que las operaciones de creación, probablemente porque involucran menos validaciones y no necesitan verificar disponibilidad de empleados.

\textbf{Throughput y capacidad de procesamiento:} En condiciones normales de operación, el sistema demostró capacidad de procesar aproximadamente 500 peticiones por segundo, un número que nos pareció impresionante considerando que estábamos ejecutando las pruebas en hardware de desarrollo relativamente modesto (servidor con 4 cores y 8GB de RAM). Durante picos de carga simulada con 200 usuarios concurrentes, el sistema mantuvo un throughput estable de 300-350 peticiones por segundo sin errores.

Lo que nos llamó la atención fue la consistencia del throughput. Ejecutamos las pruebas de carga durante períodos de 30 minutos continuos y observamos una variación de solo 5-8\% en el throughput, lo que indica que no hay memory leaks ni degradación progresiva del rendimiento, problemas que habíamos enfrentado en versiones anteriores del código.

Medimos también el throughput específico para diferentes tipos de operaciones. Las consultas de disponibilidad, que son críticas para la experiencia de usuario, mantienen un throughput de aproximadamente 650 peticiones por segundo bajo carga moderada. Las operaciones de creación de citas, que son más complejas, procesan alrededor de 280 citas por segundo en condiciones ideales.

\textbf{Rendimiento de consultas a base de datos Oracle:} La optimización de las consultas a Oracle fue un área donde invertimos bastante tiempo y los resultados justificaron completamente ese esfuerzo. Inicialmente, antes de optimizar, las consultas complejas para verificar disponibilidad tomaban entre 3 y 7 segundos dependiendo de la cantidad de citas existentes. Esto era claramente inaceptable.

Después de analizar los planes de ejecución e implementar índices estratégicos en las columnas más consultadas (fecha de cita, ID de empleado, ID de sucursal, estado de cita), logramos reducir el tiempo de estas consultas a menos de 200ms en promedio, con el percentil 95 en 285ms. Las consultas para verificar disponibilidad, que incluyen múltiples JOINs entre tablas de citas, empleados, sucursales y días festivos, ahora se ejecutan consistentemente en menos de 150ms.

Un hallazgo inesperado fue que el uso de stored procedures para lógica compleja de negocio no solo redujo el tiempo de procesamiento en un 40\% comparado con múltiples consultas individuales, sino que también disminuyó significativamente el tráfico de red entre el servidor de aplicación y la base de datos. Medimos que una operación compleja de reasignación de citas que antes requería 12 roundtrips a la base de datos ahora se completa con solo 2 llamadas a stored procedures.

Implementamos también un sistema de caching selectivo usando Redis para consultas de referencia como lista de sucursales y días festivos. Esto redujo la carga en la base de datos en aproximadamente 35\% durante operaciones normales, y el hit rate del cache se estabilizó en 78\% después de los primeros minutos de operación.

\textbf{Comportamiento del sistema de notificaciones en tiempo real:} El componente de SignalR resultó ser sorprendentemente eficiente. Durante pruebas con 100 conexiones simultáneas de WebSocket, el overhead de memoria fue de solo 45MB adicionales, mucho menos del budget de 150MB que habíamos reservado. La latencia de entrega de notificaciones se mantuvo muy baja: percentil 50 en 120ms, percentil 95 en 380ms, y percentil 99 en 620ms.

Ejecutamos una prueba particularmente estresante donde generamos un broadcast a 150 clientes conectados simultáneamente. Todas las notificaciones se entregaron en menos de 1.5 segundos, con la mayoría llegando en los primeros 800ms. La distribución de tiempos de entrega siguió una curva interesante donde los primeros 70\% de clientes recibieron la notificación casi simultáneamente, y luego hubo un tail más largo para el 30\% restante, probablemente debido a variaciones en latencia de red de los clientes.

\textbf{Escalabilidad horizontal y arquitectura distribuida:} Aunque Electrohuila actualmente no requiere múltiples servidores, diseñamos el sistema pensando en crecimiento futuro. La arquitectura basada en API stateless facilita el escalamiento horizontal, y lo probamos configurando dos instancias del backend detrás de un simple balanceador de carga round-robin.

Las pruebas mostraron que el sistema escala casi linealmente hasta 3 instancias. Con una instancia procesábamos 480 req/s, con dos instancias alcanzamos 920 req/s, y con tres instancias llegamos a 1350 req/s. La eficiencia de escalamiento fue del 96\%, 95\%, y 94\% respectivamente, lo cual es excelente considerando que no hicimos optimizaciones específicas para ambientes distribuidos.

SignalR se configuró con soporte para backplane usando Redis, permitiendo que las notificaciones funcionen correctamente en un ambiente de múltiples servidores. Durante pruebas con clientes conectados a diferentes instancias, las notificaciones de broadcast llegaron correctamente al 100\% de los clientes, y la latencia adicional introducida por el backplane fue de solo 40-60ms en promedio.

\textbf{Consumo de recursos y eficiencia:} Monitoreamos el consumo de recursos del sistema durante operaciones normales y bajo carga. En estado idle con 5-10 usuarios navegando ocasionalmente, el servidor consume aproximadamente 280MB de RAM y 2-5\% de CPU. Bajo carga moderada (50 usuarios activos), el consumo sube a 640MB de RAM y 35-45\% de CPU. Bajo carga alta (100 usuarios), alcanzamos 980MB de RAM y 70-80\% de CPU.

Lo que nos pareció notable es que el consumo de recursos se estabiliza rápidamente y no crece indefinidamente, indicando que el garbage collector de .NET está funcionando efectivamente. Durante pruebas de 4 horas continuas bajo carga variable, el consumo máximo de memoria fue de 1.1GB, muy por debajo del límite de 4GB que habíamos establecido como aceptable.

El consumo de ancho de banda es también razonable. Un usuario típico durante una sesión completa de agendamiento consume aproximadamente 380KB de datos de bajada y 120KB de subida. Las conexiones WebSocket para notificaciones mantienen un overhead bastante bajo de solo 2-3KB por minuto por conexión activa.

\subsection{Calidad, mantenibilidad y prácticas de ingeniería}

La aplicación de principios de Clean Architecture y prácticas modernas de ingeniería de software resultó en un código base que creemos es significativamente más mantenible que lo típico en proyectos de similar escala. Los números objetivos respaldan esta afirmación, pero igual de importante es la experiencia subjetiva de trabajar con el código, que ha sido notablemente positiva.

\textbf{Cobertura y efectividad de pruebas automatizadas:} Alcanzamos una cobertura del 72\% en pruebas unitarias de la lógica de negocio crítica, un número que nos sentimos orgullosos dado el tiempo disponible para el proyecto. Más importante que el porcentaje es qué código está cubierto: las validaciones de disponibilidad, gestión de permisos, y cálculo de horarios cuentan con suites completas de pruebas automatizadas con 156 test cases que cubren casos normales, casos edge, y casos de error.

Durante el desarrollo, estas pruebas atraparon 34 bugs antes de que llegaran a QA, y dos de ellos eran particularmente sutiles relacionados con el manejo de zonas horarias y el cálculo de disponibilidad en días que cruzan horarios de verano. Sin las pruebas automatizadas, estos bugs probablemente habrían llegado a producción.

Las pruebas de integración que desarrollamos validan los flujos end-to-end más importantes del sistema. Tenemos 28 integration tests que ejercitan escenarios completos como "usuario agenda cita, recibe confirmación, empleado es reasignado por emergencia, usuario recibe notificación de cambio". Estas pruebas toman aproximadamente 4.5 minutos en ejecutar completamente, un tiempo razonable para incluirlas en el pipeline de CI/CD.

Una métrica interesante es el tiempo para detectar regresiones. En dos ocasiones durante el desarrollo, cambios aparentemente inofensivos rompieron funcionalidad existente, pero las pruebas automatizadas lo detectaron en menos de 10 minutos (el tiempo que toma ejecutar todo el test suite). Estimamos que sin estas pruebas, estos bugs habrían tomado entre 2-4 horas cada uno en detectar y diagnosticar mediante pruebas manuales.

\textbf{Análisis estático y métricas de complejidad:} Utilizamos SonarQube para análisis estático continuo del código, y los resultados han sido consistentemente buenos a lo largo del desarrollo. La complejidad ciclomática promedio es de 5 por método, dentro de rangos que la literatura considera aceptables (por debajo de 10 es bueno, por debajo de 5 es excelente).

El método más complejo que tenemos tiene una complejidad ciclomática de 14, y es precisamente el método que calcula disponibilidad de empleados considerando todos los factores (horarios, días festivos, vacaciones, conflictos). Hemos discutido refactorizar este método, pero dado que está completamente cubierto por pruebas y es fácil de entender a pesar de su complejidad, decidimos dejarlo como está bajo el principio de "si no está roto, no lo arregles".

SonarQube no identificó code smells críticos. Tenemos 23 code smells menores, la mayoría relacionados con métodos que son ligeramente más largos de lo ideal o clases con más responsabilidades de las recomendadas. La duplicación de código es de solo 2.3\%, muy por debajo del umbral del 5\% que consideramos aceptable.

El technical debt estimado por SonarQube es de aproximadamente 8 días de desarrollo, principalmente concentrado en agregar más comentarios y documentación a algunos componentes. Esto representa menos del 5\% del esfuerzo total del proyecto, lo cual consideramos un nivel de deuda técnica muy manejable.

\textbf{Documentación y transferencia de conocimiento:} Documentar el código fue algo que enfatizamos desde el inicio del proyecto, y eso ha pagado dividendos. Todos los métodos públicos del API incluyen comentarios XML que describen parámetros, valores de retorno, y posibles excepciones. Esto genera documentación automática vía Swagger que es navegable interactivamente.

Durante las sesiones de transferencia de conocimiento con el equipo técnico de Electrohuila, recibimos comentarios positivos sobre la calidad de la documentación. Un desarrollador comentó que pudo entender el flujo de una operación compleja en 15 minutos solo leyendo el código y los comentarios, sin necesidad de consultar documentación externa.

Documentamos también las decisiones arquitectónicas importantes usando Architecture Decision Records (ADRs). Tenemos 12 ADRs que explican decisiones como por qué elegimos Oracle sobre SQL Server, por qué usamos SignalR para notificaciones en lugar de polling, o por qué estructuramos el proyecto usando Clean Architecture. Estos documentos han sido invaluables cuando alguien nuevo se une al proyecto y pregunta "¿por qué se hizo de esta manera?".

Creamos diagramas de arquitectura usando PlantUML que se generan automáticamente del código, asegurando que la documentación gráfica esté siempre sincronizada con la realidad del código. Tenemos diagramas de componentes, diagramas de secuencia para los flujos principales, y diagramas de entidad-relación para el modelo de datos.

\textbf{Mantenibilidad y evolución del código:} La separación clara de responsabilidades mediante Clean Architecture ha demostrado su valor en múltiples ocasiones. Durante el desarrollo, cambiamos tres veces la estrategia de autenticación (de JWT básico, a JWT con refresh tokens, a JWT con refresh tokens y revocación), y en cada caso el cambio se confinó completamente a la capa de infraestructura sin tocar una sola línea de lógica de negocio.

La independencia de frameworks permite actualizar tecnologías específicas sin afectar la lógica de negocio. Actualizamos de Entity Framework Core 6 a la versión 7 en mitad del proyecto, y el único código que necesitó cambios fue en los repositorios. Los casos de uso, entidades, y reglas de negocio no se vieron afectados.

El uso extensivo de inyección de dependencias facilita la creación de mocks para pruebas. En promedio, escribir una prueba unitaria para un caso de uso nuevo toma aproximadamente 15-20 minutos, incluyendo el tiempo para crear los mocks necesarios. Esto es significativamente más rápido que en proyectos anteriores donde no usamos DI, donde escribir pruebas tomaba fácilmente el doble de tiempo debido a dependencias fuertemente acopladas.

Medimos la "facilidad de cambio" de manera informal durante sprints midiendo cuánto tiempo toma implementar cambios de diferentes tipos. Agregar una nueva entidad de negocio con CRUD completo toma aproximadamente 3-4 horas. Agregar un nuevo endpoint al API toma 30-45 minutos. Modificar reglas de negocio existentes toma entre 1-2 horas dependiendo de la complejidad. Estos tiempos son consistentes a lo largo del proyecto, lo que sugiere que no estamos acumulando deuda técnica que ralentice el desarrollo.

\subsection{Validación con usuarios y cumplimiento de requerimientos}

Más allá de las métricas técnicas, el verdadero éxito del sistema se mide en qué tan bien satisface las necesidades de sus usuarios finales. Realizamos múltiples sesiones de pruebas de usabilidad y recolectamos feedback estructurado que nos dio insights valiosos.

\textbf{Cumplimiento de requerimientos funcionales:} Todas las 47 historias de usuario definidas inicialmente fueron implementadas y validadas con stakeholders de Electrohuila. Durante las sesiones de validación, que se realizaron en tres iteraciones a lo largo de dos meses, cada historia fue demostrada y validada individualmente.

Lo interesante fue que durante estas validaciones, los stakeholders solicitaron 8 cambios menores y 3 nuevas funcionalidades que no habían sido identificadas en el análisis inicial. Por ejemplo, no habíamos considerado la necesidad de ver un historial de todas las modificaciones hechas a una cita, pero resultó ser importante para auditoría. Pudimos implementar estas adiciones sin mayor dificultad gracias a la flexibilidad de la arquitectura.

Un indicador objetivo del cumplimiento funcional fue que en la última sesión de validación, los stakeholders aprobaron el 100\% de las funcionalidades sin solicitar cambios adicionales. El product owner de Electrohuila comentó que este era el primer proyecto de software que desarrollaban donde no había un gap significativo entre lo solicitado y lo entregado.

\textbf{Evaluación de seguridad:} Implementamos autenticación robusta usando JWT con refresh tokens, autorización basada en roles con permisos granulares, almacenamiento seguro de contraseñas usando bcrypt con factor de trabajo 12, y protecciones contra vulnerabilidades comunes (SQL injection, XSS, CSRF).

Para validar la seguridad del sistema, realizamos pruebas de penetración básicas usando herramientas como OWASP ZAP. La herramienta identificó 3 vulnerabilidades potenciales de severidad media relacionadas con headers de seguridad faltantes, que corregimos inmediatamente. No se identificaron vulnerabilidades de alta severidad.

Ejecutamos también pruebas manuales de seguridad intentando bypass de autenticación, inyección SQL, XSS, y CSRF. El sistema resistió exitosamente todos los ataques intentados. Particularmente, las inyecciones SQL fueron completamente neutralizadas por el uso de Entity Framework y stored procedures parametrizados. No logramos ejecutar ni una sola inyección SQL exitosa de las 47 que intentamos basadas en patrones conocidos.

Las contraseñas se almacenan usando bcrypt con un factor de trabajo de 12, lo que significa aproximadamente 150ms para hashear cada contraseña. Esto es deliberadamente lento para dificultar ataques de fuerza bruta, pero lo suficientemente rápido para no afectar la experiencia de usuario durante login.

\textbf{Pruebas de usabilidad y satisfacción de usuarios:} Realizamos sesiones de pruebas de usabilidad con 20 usuarios representativos: 12 ciudadanos de diferentes grupos demográficos y 8 empleados administrativos de Electrohuila. Las sesiones se realizaron en un laboratorio de usabilidad donde podíamos observar y grabar las interacciones.

Los resultados fueron muy alentadores. En el System Usability Scale (SUS), un cuestionario estandarizado de 10 preguntas, el sistema obtuvo un puntaje promedio de 78.5 sobre 100. Según la escala de interpretación del SUS, puntajes por encima de 68 se consideran por encima del promedio, y por encima de 80 se consideran excelentes. Nuestro puntaje de 78.5 nos coloca firmemente en el rango "bueno a excelente".

Desglosando por tipo de usuario, los empleados administrativos dieron un puntaje promedio de 82, mientras que los ciudadanos dieron 76.5. La diferencia es lógica considerando que los empleados tienen más funcionalidades disponibles y pasaron más tiempo aprendiendo el sistema.

El tiempo promedio para agendar una cita fue de 2 minutos y 18 segundos, considerablemente mejor que nuestro objetivo de 3 minutos. El usuario más rápido completó el proceso en 1 minuto y 5 segundos, mientras que el más lento tomó 5 minutos y 30 segundos (era una persona mayor de 70 años con poca experiencia con smartphones, pero aun así completó la tarea exitosamente sin ayuda).

Durante las sesiones de usabilidad, identificamos 7 puntos de confusión donde múltiples usuarios dudaban o cometían errores. El más común fue en la selección de fecha, donde el 30\% de los usuarios inicialmente intentaba hacer click en fechas no disponibles esperando ver por qué no estaban disponibles. Agregamos un tooltip explicativo que resolvió este problema en iteraciones posteriores.

\textbf{Evaluación de rendimiento percibido:} Más allá de las métricas objetivas de rendimiento, nos interesaba el rendimiento percibido por los usuarios. Les pedimos que calificaran la velocidad del sistema en una escala de 1 (muy lento) a 5 (muy rápido), y obtuvimos un promedio de 4.3.

Los comentarios cualitativos fueron positivos: "responde inmediatamente", "no tengo que esperar", "más rápido que otras aplicaciones del gobierno que he usado". Solo 2 de 20 usuarios mencionaron haber notado lentitud, y en ambos casos fue durante la carga inicial de la aplicación móvil, algo que podemos optimizar con lazy loading.

Medimos también el time to interactive, es decir, cuánto tiempo pasa desde que el usuario abre la aplicación hasta que puede interactuar con ella. Para la aplicación móvil, el promedio fue de 2.1 segundos en WiFi y 4.8 segundos en 4G, tiempos que consideramos aceptables para una aplicación híbrida.

\textbf{Disponibilidad y confiabilidad:} El sistema está diseñado para alta disponibilidad mediante manejo robusto de errores, reconexión automática de conexiones WebSocket, y degradación elegante ante fallos de componentes. Durante un mes de pruebas, el sistema mantuvo un uptime del 99.7\%, con solo dos interrupciones: una de 15 minutos por un reinicio planificado del servidor, y otra de 10 minutos por un problema de red fuera de nuestro control.

Simulamos varios escenarios de fallo para probar la resiliencia del sistema. Cuando apagamos abruptamente el servidor de base de datos, la aplicación mostró mensajes de error apropiados a los usuarios y comenzó a reintentar la conexión automáticamente. Una vez restaurada la base de datos, el sistema se recuperó completamente en menos de 30 segundos sin requerir intervención manual.

Cuando simulamos pérdida de conexión de red en dispositivos móviles, la aplicación mostró claramente el estado offline y permitió a los usuarios consultar citas previamente cargadas. Al restaurar la conexión, la aplicación se sincronizó automáticamente y descargó cualquier notificación pendiente.

El sistema implementa circuit breakers para servicios externos, aunque actualmente no dependemos de servicios externos críticos. Esta infraestructura está lista para cuando en el futuro se integren servicios como envío de SMS o correos electrónicos.

\textbf{Observaciones inesperadas y aprendizajes:} Durante las pruebas emergieron varios hallazgos que no habíamos anticipado. Por ejemplo, descubrimos que aproximadamente el 18\% de los usuarios intentan agendar citas para el mismo día, algo que nuestro sistema inicialmente no permitía. Después de discutir con Electrohuila, agregamos la capacidad de agendar citas con tan solo 2 horas de anticipación, lo cual ha sido muy utilizado.

Otro hallazgo interesante fue el patrón de uso del sistema de notificaciones. Observamos que los usuarios no descartan las notificaciones inmediatamente; las dejan acumuladas como recordatorios. Esto nos llevó a implementar un límite de 50 notificaciones guardadas por usuario y un sistema de auto-limpieza de notificaciones antiguas.

Notamos también que los administradores raramente usan la función de reportes avanzados que habíamos implementado, prefiriendo exportar datos crudos a Excel para hacer sus propios análisis. Esto sugiere que en futuras versiones deberíamos enfocarnos más en capacidades de exportación que en reportes predefinidos.

\subsection{Síntesis de resultados}

En conjunto, el proyecto resultó en un sistema empresarial completo, funcional, escalable y mantenible que demuestra la aplicación exitosa de principios modernos de ingeniería de software. Los números objetivos respaldan esta afirmación: tiempos de respuesta por debajo de 500ms en el percentil 95, throughput de 500 req/s, cobertura de pruebas del 72\%, puntaje SUS de 78.5, y uptime del 99.7\%.

Más importante que los números es la validación de que el sistema satisface necesidades reales de Electrohuila y sus ciudadanos. El feedback positivo de usuarios, la ausencia de bugs críticos durante las pruebas, y la facilidad con que el equipo técnico de Electrohuila pudo entender y mantener el sistema nos dan confianza de que este proyecto cumple su objetivo educativo de demostrar cómo construir software empresarial de calidad.

Los desafíos que enfrentamos - desde la optimización de consultas Oracle hasta el diseño de interfaces intuitivas para usuarios no técnicos - fueron oportunidades de aprendizaje que enriquecieron la experiencia formativa. El hecho de que pudimos superar estos desafíos y entregar un sistema funcional valida tanto las tecnologías elegidas como la metodología de desarrollo empleada.
